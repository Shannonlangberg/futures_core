from datetime import datetime
# SIMPLIFIED Environment Loading (FIXED)
import os
from pathlib import Path

try:
    from dotenv import load_dotenv
    load_dotenv()
    print("‚úÖ Environment variables loaded")
except ImportError:
    print("‚ö†Ô∏è Using system environment variables")

from flask import Flask, request, jsonify, send_from_directory, render_template, send_file
from flask_cors import CORS
from flask_talisman import Talisman
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
import os
import logging
import random
import time
import re
import base64
import uuid
import atexit
import asyncio
import aiohttp
from datetime import timedelta
from typing import Dict, Optional, List
from functools import lru_cache
from concurrent.futures import ThreadPoolExecutor

# Import handling with fallbacks
try:
    import gspread
    from google.oauth2.service_account import Credentials
    GSPREAD_AVAILABLE = True
except ImportError:
    GSPREAD_AVAILABLE = False
    print("‚ö†Ô∏è Google Sheets support not available - install gspread and google-auth")

try:
    import anthropic
    ANTHROPIC_AVAILABLE = True
except ImportError:
    ANTHROPIC_AVAILABLE = False
    print("‚ö†Ô∏è Anthropic Claude support not available - install anthropic")

try:
    from elevenlabs import ElevenLabs
    ELEVENLABS_AVAILABLE = True
except ImportError:
    ELEVENLABS_AVAILABLE = False
    print("‚ö†Ô∏è ElevenLabs support not available - install elevenlabs")

import json

app = Flask(__name__)
CORS(app)

# REMOVED: All pygame imports and server-side audio code

# Initialize Flask-Limiter
limiter = Limiter(
    app=app,
    key_func=get_remote_address,
    default_limits=["200 per day", "50 per hour"]
)

# SIMPLIFIED logging setup (FIXED)
def setup_logging():
    """Setup enhanced logging with proper error handling"""
    try:
        os.makedirs('logs', exist_ok=True)
        
        logging.basicConfig(
            level=logging.WARNING,  # Only show warnings and errors
            format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('logs/futures_link.log'),
                logging.StreamHandler()
            ]
        )
        # logging.info("Logging system initialized successfully")
        return True
        
    except Exception as e:
        # print(f"‚ùå Logging setup failed: {e}")
        return False

setup_logging()
logger = logging.getLogger(__name__)

class EnhancedChurchAssistant:
    def parse_month_range(self, text: str) -> Optional[tuple]:
        """Extract a month range and optional year from text like 'from February to April 2023'"""
        import calendar
        text = text.lower()
        months = list(calendar.month_name)
        month_indices = []

        for i, month in enumerate(months):
            if month and month.lower() in text:
                month_indices.append((i, text.index(month.lower())))

        if len(month_indices) >= 2:
            month_indices.sort(key=lambda x: x[1])
            start_month = month_indices[0][0]
            end_month = month_indices[1][0]

            tokens = text.split()
            year = None
            for token in tokens:
                if token.isdigit() and 2000 <= int(token) <= 2100:
                    year = int(token)
                    break
            return (start_month, end_month, year)
        return None

    def is_asking_for_data(self, text: str) -> bool:
        """üî• ENHANCED: Determine if user is ASKING for data vs PROVIDING data"""
        text = text.lower()
        
        # Clear question indicators
        question_words = [
            'how many', 'what were', 'what are', 'tell me', 'show me', 'what was',
            'which campus', 'average attendance', 'what is the average', 'give me stats',
            'any idea', 'do you know', 'compare', 'how is', 'summary', 'what about',
            'can you tell me', 'do we have', 'what do we have', 'what\'s the'
        ]
        if any(q in text for q in question_words):
            return True
            
        # Question marks
        if '?' in text:
            return True
            
        # Providing data indicators (they're giving us stats, not asking)
        providing_indicators = [
            'had', 'got', 'we had', 'there were', 'attendance was', 'np', 'nc',
            'was', 'were', 'today we had', 'this week', 'sunday we had'
        ]
        if any(p in text for p in providing_indicators):
            return False
            
        # Numbers with campus names usually means providing
        for campus in self.campuses:
            if campus.lower() in text and any(char.isdigit() for char in text):
                return False
                
        return False

    def handle_voice_input(self, text):
        try:
            parsed = self.parse_input(text)
            response = self.generate_response(parsed)
            return response
        except TypeError as e:
            logger.exception("‚ùå TypeError in handle_voice_input")
            return "Hmm, I got confused by that. Can you try saying it a little differently?"
        except Exception as e:
            logger.exception("‚ùå Unexpected error in handle_voice_input")
            return "Sorry, I had trouble processing that. Could you say it another way?"

    # def handle_stat_query(self, text: str) -> Optional[str]:
        """üî• ENHANCED: Handle queries like 'new Christians in March at South' - ONLY when user asks"""
        
        # üö® CRITICAL FIX: Only respond if they're explicitly asking for data
        if not self.is_asking_for_data(text):
            return None
            
            
        stat_keywords = {
            'new christians': 'new_christians',
            'youth salvations': 'new_youth_christians',
            'kids salvations': 'kids_salvations',
            'total attendance': 'total_attendance',
            'new people': 'new_people',
            'youth attendance': 'youth_attendance',
            'new youth': 'new_youth',
            'new kids': 'new_kids',
            'kids total': 'kids_total',
            'connect groups': 'connect_groups'
        }

        text_lower = text.lower()

        # Check for month range like "from February to April"
        month_range = self.parse_month_range(text)
        if month_range:
            start_month, end_month, year = month_range
            campus = self.extract_campus_enhanced(text)
            summaries = []
            for m in range(start_month, end_month + 1):
                summaries.append(self.get_annual_summary(campus, year=year, month=m))
            return "\n".join(summaries)

        # --- Salvation Health Queries (church-wide) ---
        if any(phrase in text_lower for phrase in [
            "how many people have given their lives",
            "how many salvations",
            "how many people got saved",
            "how many people became christians"
        ]):
            year = None
            for token in text.split():
                if token.isdigit() and 2000 <= int(token) <= 2100:
                    year = int(token)
                    break
            year = year or datetime.now().year
            total = sum(self.get_stat_total(c, "new_christians", year) or 0 for c in self.campuses)
            return f"In {year}, {total} people have given their lives to Jesus across all campuses."

        # Parse explicit month and year from text for summary/statistics summary queries
        import calendar
        month = None
        year = None
        for i, m in enumerate(calendar.month_name):
            if m and f"in {m.lower()}" in text_lower:
                month = i
                break
        for token in text.split():
            if token.isdigit() and 2000 <= int(token) <= 2100:
                year = int(token)
                break
        if "summary" in text_lower or "how is" in text_lower:
            campus = self.extract_campus_enhanced(text)
            return self.get_annual_summary(campus, year=year, month=month)

        stat_key = next((k for k, v in stat_keywords.items() if k in text_lower), None)
        if not stat_key:
            return None

        key = stat_keywords[stat_key]
        campus = self.extract_campus_enhanced(text) or self.current_campus

        # Support whole-church year-over-year comparisons if no campus is mentioned and phrases like "this year vs last year" or "year over year" are used
        year_over_year_phrases = [
            "compared to last year",
            "compare to last year",
            "this year vs last year",
            "year over year",
            "year-on-year",
            "year on year"
        ]
        now = datetime.now()
        year = now.year
        month = None
        if any(phrase in text_lower for phrase in year_over_year_phrases):
            # If no campus in text and no campus in context, do whole-church comparison
            if campus is None:
                # All campuses
                this_year_total = sum(self.get_stat_total(c, key, year) or 0 for c in self.campuses)
                last_year_total = sum(self.get_stat_total(c, key, year - 1) or 0 for c in self.campuses)
                if this_year_total is None or last_year_total is None or (this_year_total == 0 and last_year_total == 0):
                    return f"Sorry, I couldn't find enough data to compare {stat_key} across all campuses year over year."
                if last_year_total == 0:
                    return f"Last year's {stat_key} for all campuses was zero, so I can't calculate a comparison."
                change_percent = ((this_year_total - last_year_total) / last_year_total) * 100
                direction = "up" if change_percent > 0 else "down"
                return f"Across all campuses, there were {this_year_total} {stat_key} this year, {direction} {abs(change_percent):.1f}% from last year's {last_year_total}."
            else:
                this_year_total = self.get_stat_total(campus, key, year)
                last_year_total = self.get_stat_total(campus, key, year - 1)
                if this_year_total is None or last_year_total is None:
                    return f"Sorry, I couldn't find enough data to compare {stat_key} for {campus} year over year."
                if last_year_total == 0:
                    return f"Last year's {stat_key} for {campus} was zero, so I can't calculate a comparison."
                change_percent = ((this_year_total - last_year_total) / last_year_total) * 100
                direction = "up" if change_percent > 0 else "down"
                return f"{campus} had {this_year_total} {stat_key} this year so far, {direction} {abs(change_percent):.1f}% from last year's {last_year_total}."

        # Check if asking for top campus
        if "which campus" in text_lower and ("most" in text_lower or "highest" in text_lower):
            for label, key2 in stat_keywords.items():
                if label in text_lower or (label == "new christians" and "salvation" in text_lower):
                    now = datetime.now()
                    year2 = now.year
                    month2 = now.month - 1 or 12
                    if month2 == 12:
                        year2 -= 1
                    return self.get_top_campus_for_stat(key2, year2, month2)

        # Check for "last month"
        if "last month" in text_lower:
            month = now.month - 1 or 12
            if month == 12:
                year -= 1
        else:
            import calendar
            for i, m in enumerate(calendar.month_name):
                if m and f"in {m.lower()}" in text_lower:
                    month = i
                    break

        # Monthly trend/trending and new trend phrases
        if any(term in text_lower for term in ["trending", "trend", "going up", "improving", "getting better", "on the rise"]):
            trend_summary = self.get_monthly_trend_summary(campus, key, year, month)
            if trend_summary:
                if "increased" in trend_summary or "up" in trend_summary:
                    trend_summary += " Keep it up‚Äîmomentum is building!"
                return trend_summary
            else:
                return f"Sorry, I couldn't determine the trend for {campus} {stat_key}."

        # If no campus still, prompt for campus
        if not campus:
            return "Which campus are you referring to?"

        total = self.get_stat_total(campus, key, year, month)
        import calendar
        when = f"{calendar.month_name[month]} {year}" if month else str(year)
        if total is not None:
            return f"Here's the summary for {campus} in {when}: {total} {stat_key}."

        # Detect celebration or breakthrough queries
        if any(phrase in text_lower for phrase in [
            "breakthrough month",
            "celebration",
            "any spikes",
            "spike in salvations",
            "breakout",
            "surge"
        ]):
            best_campus = None
            best_increase = 0
            best_month = None
            now = datetime.now()
            for campus in self.campuses:
                for month in range(1, 13):
                    current_total = self.get_stat_total(campus, "new_christians", now.year, month)
                    prev_month = month - 1 or 12
                    prev_year = now.year if month > 1 else now.year - 1
                    previous_total = self.get_stat_total(campus, "new_christians", prev_year, prev_month)
                    if current_total is None or previous_total is None or previous_total == 0:
                        continue
                    increase = (current_total - previous_total) / previous_total
                    if increase > best_increase and current_total >= 5:
                        best_increase = increase
                        best_campus = campus
                        best_month = month
            if best_campus:
                import calendar
                return f"{best_campus} had a breakthrough month in {calendar.month_name[best_month]} with a {best_increase*100:.1f}% spike in salvations!"
            else:
                return "No major spikes or breakthrough months found recently."

        return f"Sorry, I couldn't find any {stat_key} data for {campus} in {when}."

    # def get_monthly_trend_summary(self, campus: Optional[str], stat_key: str, year: Optional[int] = None, month: Optional[int] = None) -> Optional[str]:
        """Compare this month's stat with last month's and return a summary if data is sufficient"""
        if not self.sheets_client or not self.spreadsheet or not campus:
            return None

        try:
            now = datetime.now()
            year = year or now.year
            month = month or now.month

            # Calculate previous month and year
            prev_month = month - 1 or 12
            prev_year = year - 1 if prev_month == 12 else year

            current_total = self.get_stat_total(campus, stat_key, year, month)
            previous_total = self.get_stat_total(campus, stat_key, prev_year, prev_month)

            if current_total is None or previous_total is None:
                return None

            if previous_total == 0:
                return f"No {stat_key.replace('_', ' ')} were recorded in {prev_month}/{prev_year} to compare."

            percent_change = ((current_total - previous_total) / previous_total) * 100
            direction = "increased" if percent_change > 0 else "decreased"
            return f"{campus}'s {stat_key.replace('_', ' ')} has {direction} by {abs(percent_change):.1f}% compared to last month."
        except Exception as e:
            logger.error(f"‚ùå Monthly trend comparison failed: {e}")
            return None

    # def get_annual_summary(self, campus: Optional[str] = None, year: Optional[int] = None, month: Optional[int] = None) -> str:
        """Summarize stats for a campus or all campuses in a year or month"""
        if not self.sheets_client or not self.spreadsheet:
            return "Stats summary is unavailable at the moment."

        try:
            import calendar
            year = year or datetime.now().year
            worksheet = self.spreadsheet.sheet1
            records = worksheet.get_all_records()

            campuses = [campus] if campus else self.campuses
            summary = []

            for camp in campuses:
                totals = {
                    'attendance': 0,
                    'new_people': 0,
                    'new_christians': 0,
                    'youth_salvations': 0,
                    'kids_salvations': 0
                }

                for row in records:
                    if row.get('Campus') != camp:
                        continue
                    try:
                        date = datetime.strptime(row.get('Sunday Date', ''), '%Y-%m-%d')
                        if date.year != year:
                            continue
                        if month and date.month != month:
                            continue
                    except Exception:
                        continue

                    totals['attendance'] += int(row.get('Total Attendance') or 0)
                    totals['new_people'] += int(row.get('New People') or 0)
                    totals['new_christians'] += int(row.get('New Christians') or 0)
                    totals['youth_salvations'] += int(row.get('New Youth Christians') or 0)
                    totals['kids_salvations'] += int(row.get('Kids Salvations') or 0)

                time_label = f"{calendar.month_name[month]} {year}" if month else str(year)
                summary.append(f"{camp}: {totals['attendance']} attendance, {totals['new_people']} new, "
                               f"{totals['new_christians']} salvations, {totals['youth_salvations']} youth saved, "
                               f"{totals['kids_salvations']} kids saved ({time_label})")

            time_label = f"{calendar.month_name[month]} {year}" if month else str(year)
            if campus:
                return f"Here's how {campus} has been doing in {time_label}: {summary[0]}"
            else:
                return f"Here's a summary for all campuses in {time_label}:\n" + "\n".join(summary)

        except Exception as e:
            logger.error(f"‚ùå Failed to generate summary: {e}")
            return "There was an error generating the summary."

    # def get_top_campus_for_stat(self, stat_key: str, year: Optional[int] = None, month: Optional[int] = None) -> Optional[str]:
        """Return the campus with the highest value for a given stat in a given month/year"""
        if not self.sheets_client or not self.spreadsheet:
            return None
        try:
            worksheet = self.spreadsheet.sheet1
            records = worksheet.get_all_records()
            campus_totals = {}

            for row in records:
                campus = row.get('Campus')
                if not campus:
                    continue
                date_str = row.get('Sunday Date')
                if not date_str:
                    continue
                try:
                    row_date = datetime.strptime(date_str, '%Y-%m-%d')
                    if year and row_date.year != year:
                        continue
                    if month and row_date.month != month:
                        continue
                except ValueError:
                    continue

                value = row.get(stat_key.replace('_', ' ').title())
                if isinstance(value, int):
                    campus_totals[campus] = campus_totals.get(campus, 0) + value
                elif isinstance(value, str) and value.isdigit():
                    campus_totals[campus] = campus_totals.get(campus, 0) + int(value)

            if not campus_totals:
                return None

            top_campus = max(campus_totals.items(), key=lambda x: x[1])
            return f"{top_campus[0]} had the most {stat_key.replace('_', ' ')} with {top_campus[1]} logged."
        except Exception as e:
            logger.error(f"‚ùå Failed to compute top campus for {stat_key}: {e}")
            return None

    def __init__(self):
        """Initialize enhanced voice assistant with Claude AI"""
        # print("üöÄ Starting ENHANCED Futures Link Voice Assistant with Claude...")
        # print("=" * 60)
        # ... rest of __init__ ...
        # print("‚úÖ Enhanced Voice Assistant with Claude initialized!")
        # print("‚úÖ ALL features preserved + Claude integration!")
        # print("=" * 60)
        pass  # No prints here
    
    def ensure_directories(self):
        """Ensure required directories exist"""
        directories = ['temp_audio', 'logs', 'data', 'static']
        for directory in directories:
            try:
                os.makedirs(directory, exist_ok=True)
                logger.info(f"‚úÖ Directory ensured: {directory}")
            except Exception as e:
                logger.error(f"‚ùå Failed to create directory {directory}: {e}")
    
    def setup_claude(self):
        """Setup Claude (Anthropic) AI"""
        if not ANTHROPIC_AVAILABLE:
            self.claude_client = None
            logger.warning("‚ùå Anthropic Claude not available")
            return
            
        api_key = os.getenv('ANTHROPIC_API_KEY')
        if not api_key:
            logger.warning("‚ùå ANTHROPIC_API_KEY not found")
            self.claude_client = None
            return
        
        try:
            self.claude_client = anthropic.Anthropic(api_key=api_key)
            
            # Test connection with a simple message
            test_response = self.claude_client.messages.create(
                model="claude-3-5-sonnet-20241022",
                max_tokens=10,
                messages=[{"role": "user", "content": "Test"}],
                timeout=10
            )
            logger.info("‚úÖ Claude AI connected successfully")
            self.has_claude = True
        except Exception as e:
            logger.error(f"‚ùå Claude setup failed: {e}")
            self.claude_client = None
            self.has_claude = False
    
    def setup_elevenlabs(self):
        """Setup ElevenLabs with bulletproof configuration"""
        self.elevenlabs_api_key = os.getenv('ELEVENLABS_API_KEY')
        self.elevenlabs_voice_id = os.getenv('ELEVENLABS_VOICE_ID', 'pNInz6obpgDQGcFmaJgB')
        
        if self.elevenlabs_api_key and ELEVENLABS_AVAILABLE:
            logger.info("‚úÖ ElevenLabs voice synthesis enabled")
            logger.info(f"   Voice ID: {self.elevenlabs_voice_id}")
            self.use_elevenlabs = True
            
            # Test connection
            try:
                test_audio = asyncio.run(self.generate_elevenlabs_audio("Test", test_mode=True))
                if test_audio:
                    logger.info("‚úÖ ElevenLabs test successful")
                else:
                    logger.warning("‚ö†Ô∏è ElevenLabs test failed")
                    self.use_elevenlabs = False
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è ElevenLabs test error: {e}")
                self.use_elevenlabs = False
        else:
            logger.warning("‚ö†Ô∏è ElevenLabs not available or API key missing")
            self.use_elevenlabs = False
    
    def setup_google_sheets(self):
        """Setup Google Sheets"""
        if not GSPREAD_AVAILABLE:
            self.sheets_client = None
            logger.warning("‚ùå Google Sheets not available")
            return
            
        try:
            credentials_path = os.getenv('GOOGLE_CREDENTIALS_PATH', 'credentials.json')
            if os.path.exists(credentials_path):
                scope = [
                    'https://www.googleapis.com/auth/spreadsheets',
                    'https://www.googleapis.com/auth/drive'
                ]
                creds = Credentials.from_service_account_file(credentials_path, scopes=scope)
                self.sheets_client = gspread.authorize(creds)

                sheet_name = os.getenv('GOOGLE_SHEET_NAME', 'Church Stats')
                try:
                    self.spreadsheet = self.sheets_client.open(sheet_name)
                    logger.info("‚úÖ Google Sheets connected")
                except gspread.SpreadsheetNotFound:
                    self.spreadsheet = self.sheets_client.create(sheet_name)
                    headers = [
                        'Timestamp', 'Sunday Date', 'Campus', 'Total Attendance',
                        'New People', 'New Christians', 'Youth Attendance',
                        'New Youth', 'New Youth Christians', 'Kids Total',
                        'New Kids', 'Connect Groups'
                    ]
                    self.spreadsheet.sheet1.append_row(headers)
                    logger.info("‚úÖ New spreadsheet created")
            else:
                logger.warning(f"‚ö†Ô∏è No credentials file found at {credentials_path}")
                self.sheets_client = None
                self.spreadsheet = None
        except Exception as e:
            logger.error(f"‚ùå Google Sheets setup failed: {e}")
            self.sheets_client = None
            self.spreadsheet = None
    
    def setup_memory_system(self):
        """Setup memory"""
        self.memory_file = os.path.join('data', 'conversation_memory.json')
        self.load_memory()
        logger.info("‚úÖ Memory system initialized")
    
    def load_memory(self):
        """Load conversation history"""
        try:
            if os.path.exists(self.memory_file):
                with open(self.memory_file, 'r', encoding='utf-8') as f:
                    data = json.load(f)
                    # Safe slicing: only slice if it's a list, else default to empty dict or list
                    conversations = data.get('conversations', {})
                    if isinstance(conversations, list):
                        self.conversation_history = conversations[-10:]
                    else:
                        self.conversation_history = {}
                    self.session_stats = data.get('session_stats', {})
                logger.info(f"‚úÖ Loaded {len(self.conversation_history)} conversation(s)")
        except Exception as e:
            logger.error(f"‚ùå Failed to load memory: {e}")
            self.conversation_history = {}
            self.session_stats = {}
    
    def save_memory(self):
        """Save conversation history"""
        try:
            # Safe slicing: only slice if conversation_history is a list, else use as is
            ch = self.conversation_history
            if isinstance(ch, list):
                conversations = ch[-10:]
            else:
                conversations = ch
            data = {
                'conversations': conversations,
                'session_stats': self.session_stats,
                'last_updated': datetime.now().isoformat()
            }
            with open(self.memory_file, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
        except Exception as e:
            logger.error(f"‚ùå Failed to save memory: {e}")
    
    def extract_campus_enhanced(self, text: str) -> Optional[str]:
        """üî• SUPER ENHANCED: Campus extraction - handles ALL natural variations"""
        if not text:
            return None
            
        text = text.lower().strip()
        logger.info(f"üîç Analyzing text for campus: '{text}'")
        
        # ENHANCED patterns - order by specificity to avoid conflicts
        campus_patterns = [
            # Multi-word campuses first (most specific)
            (r'\b(adelaide city|adel city|city campus|adelaide)\b', 'Adelaide City'),
            (r'\bcity\b', 'Adelaide City'),
            (r'\b(clare valley|clare)\b', 'Clare Valley'),
            (r'\b(mount barker|mt barker|barker)\b', 'Mount Barker'),
            (r'\b(victor harbour|victor harbor|victor)\b', 'Victor Harbour'),
            (r'\b(copper coast|copper)\b', 'Copper Coast'),
            
            # Single word campuses with variations
            (r'\b(paradise|para|par)\b', 'Paradise'),
            (r'\b(salisbury|sal|sali|sbury)\b', 'Salisbury'),
            (r'\bsouth\b', 'South'),  # EXACT match for "south" only
            
            # Handle common speech patterns
            (r'\bat (paradise|para|par)\b', 'Paradise'),
            (r'\bat (salisbury|sal|sali)\b', 'Salisbury'),
            (r'\bat (adelaide city|city)\b', 'Adelaide City'),
            (r'\bat south\b', 'South'),
            (r'\bat (clare valley|clare)\b', 'Clare Valley'),
            (r'\bat (mount barker|barker)\b', 'Mount Barker'),
            (r'\bat (victor harbour|victor)\b', 'Victor Harbour'),
            (r'\bat (copper coast|copper)\b', 'Copper Coast'),
        ]
        
        for pattern, campus_name in campus_patterns:
            if re.search(pattern, text):
                logger.info(f"‚úÖ Campus detected: '{text}' ‚Üí {campus_name} (pattern: {pattern})")
                return campus_name
        
        logger.info(f"üîç No campus detected in: '{text}'")
        return None
    
    def parse_stats_enhanced(self, text: str) -> Dict:
        """üî• SUPER ENHANCED: Statistics parsing - handles ALL natural speech patterns"""
        if not text:
            return {}

        stats = {}
        text_original = text
        text = text.lower()
        
        logger.info(f"üìä Parsing stats from: '{text_original}'")

        # Preserve context of current campus and last stats
        if hasattr(self, 'last_spoken_stats') and isinstance(self.last_spoken_stats, dict):
            current_context = self.last_spoken_stats.get(self.current_campus, {})
            stats.update(current_context)

        campus = self.extract_campus_enhanced(text)
        if campus:
            stats['campus'] = campus
            logger.info(f"üè´ Campus identified: {campus}")

        # ENHANCED patterns for natural speech
        patterns = {
            'total_attendance': [
                # Standard patterns
                r'(?:had|got|there were|total of|attendance was|we had)\s*(\d+)\s*(?:people|total|attendance)',
                r'(\d+)\s*(?:people|total|attendance)',
                r'attendance\s*(?:was|is|of)?\s*(\d+)',
                
                # Natural speech patterns
                r'(\d+)\s*(?:at|in)\s*(?:church|service|the service)',
                r'(?:about|around|roughly)\s*(\d+)\s*people',
                r'we had\s*(\d+)',
                r'there were\s*(\d+)',
                r'(\d+)\s*showed up',
                r'(\d+)\s*came',
                r'(\d+)\s*were there',
                r'(\d+)\s*in total',
                r'total was\s*(\d+)',
            ],
            'new_people': [
                # Standard patterns
                r'(\d+)\s*(?:new|first.?time|visitors|guests|newcomers)',
                r'(?:new|first.?time|visitors|guests)\s*(\d+)',
                r'(\d+)\s*new\s*(?:people|visitors|guests)',
                
                # Natural speech patterns
                r'(\d+)\s*(?:first time|first.time)',
                r'(\d+)\s*(?:visitor|visitors)',
                r'(\d+)\s*new\s*(?:folks|friends)',
                r'(\d+)\s*(?:guest|guests)',
                
                # Abbreviations
                r'(\d+)\s*np\b',  # "5 np" 
                r'\bnp\s*(\d+)',  # "np 5"
                r'(\d+)\s*new',   # Just "5 new"
            ],
            'new_christians': [
                # Standard patterns
                r'(\d+)\s*(?:salvation|decision|new christian|saved)',
                r'(?:salvation|decision|saved)\s*(\d+)',
                r'(\d+)\s*(?:decisions?|salvations?)',
                
                # Natural speech patterns
                r'(\d+)\s*(?:gave their life|gave their lives|got saved|became christian|became christians)',
                r'(\d+)\s*(?:accepted christ|accepted jesus)',
                r'(\d+)\s*(?:came to christ|came to jesus)',
                r'(\d+)\s*(?:prayed the prayer|said the prayer)',
                
                # Abbreviations
                r'(\d+)\s*nc\b',  # "3 nc"
                r'\bnc\s*(\d+)',  # "nc 3"
                r'(\d+)\s*sal\b',  # "3 sal" (salvations)
            ],
            'youth_attendance': [
                r'(\d+)\s*(?:youth\s+attending|youth\s+attendance|young people)',
                r'youth\s+attendance\s*(?:was|is|of)?\s*(\d+)',
                r'(\d+)\s*youth',
                r'(\d+)\s*young\s*(?:people|adults)',
                r'(\d+)\s*in\s*youth',
            ],
            'new_youth': [
                r'(\d+)\s*(?:new\s+youth|first time youth|youth visitors)',
                r'new\s+youth\s*(?:was|is|of)?\s*(\d+)',
                r'(\d+)\s*new\s*(?:young people|youth)',
            ],
            'new_youth_christians': [
                r'(\d+)\s*(?:youth\s+saved|youth\s+salvations|youth\s+decisions)',
                r'youth\s+salvations\s*(?:was|is|of)?\s*(\d+)',
                r'(\d+)\s*youth\s*(?:got saved|gave their lives)',
            ],
            'kids_total': [
                r'(\d+)\s*(?:kids\s+attending|kids\s+total|children\s+present)',
                r'kids\s+attendance\s*(?:was|is|of)?\s*(\d+)',
                r'(\d+)\s*kids',
                r'(\d+)\s*children',
                r'(\d+)\s*in\s*(?:kids|children)',
            ],
            'new_kids': [
                r'(\d+)\s*(?:new\s+kids|first time kids|kids visitors)',
                r'new\s+kids\s*(?:was|is|of)?\s*(\d+)',
                r'(\d+)\s*new\s*(?:kids|children)',
            ],
            'kids_salvations': [
                r'(\d+)\s*(?:kids\s+saved|kids\s+salvations|kids\s+decisions)',
                r'kids\s+salvations\s*(?:was|is|of)?\s*(\d+)',
                r'(\d+)\s*kids\s*(?:got saved|gave their lives)',
            ],
            'connect_groups': [
                r'(\d+)\s*(?:connect\s+groups|small\s+groups|life\s+groups)',
                r'connect\s+groups\s*(?:was|is|of)?\s*(\d+)',
                r'(\d+)\s*(?:cg|connect|groups)',
            ]
        }

        # Track which stat fields are detected in this utterance
        new_fields = set()
        for field, field_patterns in patterns.items():
            for pattern in field_patterns:
                try:
                    match = re.search(pattern, text, re.IGNORECASE)
                    if match:
                        number = int(match.group(1))
                        if 0 <= number <= 10000:
                            stats[field] = number
                            new_fields.add(field)
                            logger.info(f"üìä Found {field}: {number} (pattern: {pattern})")
                            break
                except (ValueError, IndexError, AttributeError) as e:
                    logger.debug(f"Pattern match error: {e}")
                    continue

        # Auto-fill prediction if missing key stats
        if campus and 'total_attendance' in stats and 'new_people' not in stats:
            avg_new = self.get_average_stat(campus, 'new_people') or 5  # Default fallback
            stats['new_people'] = avg_new  # Predict based on average

        # Store last spoken stats per campus
        if 'campus' in stats:
            self.last_spoken_stats = getattr(self, 'last_spoken_stats', {})
            self.last_spoken_stats[stats['campus']] = stats

        logger.info(f"üìä Final parsed stats: {stats}")
        return stats
    
    def generate_trend_insight(self, campus: str, stat_key: str) -> Optional[str]:
        """Generate insight if stat trend shows consistent growth or decline"""
        if campus not in self.session_stats or len(self.session_stats[campus]) < 3:
            return None

        recent = [s.get(stat_key) for s in self.session_stats[campus] if stat_key in s][-4:]
        if len(recent) < 3 or not all(isinstance(x, int) for x in recent):
            return None

        changes = [recent[i+1] - recent[i] for i in range(len(recent) - 1)]
        avg_change = sum(changes) / len(changes)
        if abs(avg_change) / max(recent[-2], 1) >= 0.1:  # 10% threshold
            direction = "increased" if avg_change > 0 else "decreased"
            percent = abs(avg_change) / max(recent[-2], 1) * 100
            return f"{stat_key.replace('_', ' ').title()} has {direction} {percent:.1f}% on average the last few weeks."
        return None

    def generate_claude_response(self, user_input: str, stats: Dict, context: str = "") -> str:
        """üî• ENHANCED: Claude AI response generation with better conversational flow"""
        if not self.claude_client:
            return self.generate_fallback_response(user_input, stats)

        try:
            # Build conversation history for Claude
            messages = []

            # Add recent conversation history for context
            campus_history = self.conversation_history.get(self.current_campus, [])[-3:]
            for conv in campus_history:
                if conv.get('user') and conv.get('assistant'):
                    messages.append({"role": "user", "content": conv['user']})
                    messages.append({"role": "assistant", "content": conv['assistant']})

            # Build current context
            current_context = f"User said: {user_input}"
            if stats:
                current_context += f"\nDetected data: {stats}"
            if context:
                current_context += f"\nContext: {context}"
            if self.current_campus:
                current_context += f"\nCurrent campus: {self.current_campus}"

            messages.append({"role": "user", "content": current_context})

            # Get Claude response
            response = self.claude_client.messages.create(
                model="claude-3-5-sonnet-20241022",
                max_tokens=150,
                temperature=0.7,  # Slightly higher for more natural responses
                system="""You are Link, a friendly church assistant helping pastors log stats. 
                Be conversational, helpful, and encouraging. Keep responses under 30 words when possible.
                
                Campus names: Paradise, Adelaide City, Salisbury, South, Clare Valley, Mount Barker, Victor Harbour, Copper Coast
                
                üî• ENHANCED GUIDELINES:
                - When they give you numbers, acknowledge them warmly and ask what else you can log
                - Be encouraging about growth and salvations - this is ministry!
                - Use natural, conversational language like a helpful friend
                - If they switch topics, follow their lead naturally
                - ABBREVIATIONS: "nc" = new Christians, "np" = new people
                - Always end with a question or invitation to continue the conversation
                - Guide for missing data like attendance or youth if not provided. Be encouraging.
                
                BE WARM, ENCOURAGING, AND CONVERSATIONAL!""",
                messages=messages
            )

            response_text = response.content[0].text.strip()
            
            # Only use fallback if Claude response is empty or too short
            if not response_text or len(response_text.strip()) < 5:
                response_text = self.generate_fallback_response(user_input, stats)
            
            logger.info(f"ü§ñ Claude Response: {response_text}")
            return response_text

        except Exception as e:
            logger.error(f"‚ùå Claude response failed: {e}")
            return self.generate_fallback_response(user_input, stats)

    # def compare_to_last_week(self, campus: str, stat_key: str) -> Optional[str]:
        """Compare current stat to last week's and return an insight if difference > 3%"""
        if not self.sheets_client or not self.spreadsheet:
            return None
        try:
            worksheet = self.spreadsheet.sheet1
            records = worksheet.get_all_records()
            campus_records = [r for r in records if r['Campus'] == campus and r.get(stat_key.replace('_', ' ').title())]

            if len(campus_records) < 2:
                return None  # Not enough data

            last_week_record = campus_records[-2]  # Assuming newest are at the end
            current_record = campus_records[-1]

            last_value = int(last_week_record.get(stat_key.replace('_', ' ').title(), 0))
            current_value = int(current_record.get(stat_key.replace('_', ' ').title(), 0))

            if last_value == 0:
                return None  # Avoid division by zero

            change_percent = ((current_value - last_value) / last_value) * 100

            if abs(change_percent) < 3:
                return None  # Not significant enough

            direction = "up" if change_percent > 0 else "down"
            return f"{stat_key.replace('_', ' ').title()} is {direction} {abs(change_percent):.1f}% from last week."
        except Exception as e:
            logger.error(f"‚ùå Failed to compare {stat_key}: {e}")
            return None
    
    def generate_fallback_response(self, user_input: str, stats: Dict) -> str:
        """üî• ENHANCED: Fallback response - more natural and contextual"""
        # üî• At the very start, block fallback logic for queries/questions
        if self.is_asking_for_data(user_input):
            return "Let me check that for you..."

        campus = stats.get('campus') or self.extract_campus_enhanced(user_input)

        # If they provided stats, acknowledge them warmly
        if stats and len(stats) > 1:  # More than just campus
            if campus:
                stat_summary = []
                if 'total_attendance' in stats:
                    stat_summary.append(f"{stats['total_attendance']} people")
                if 'new_people' in stats:
                    stat_summary.append(f"{stats['new_people']} new")
                if 'new_christians' in stats:
                    stat_summary.append(f"{stats['new_christians']} salvations")

                if stat_summary:
                    encouragement = ""
                    if 'new_christians' in stats and stats['new_christians'] > 0:
                        encouragement = " Praise God! "
                    return f"Great! {campus}: {', '.join(stat_summary)}.{encouragement}What else can I log?"
                else:
                    return f"Perfect! Logged stats for {campus}. Anything else?"
            else:
                return "Awesome numbers! Which campus was that for?"

        # If campus mentioned but no stats
        if campus and len(stats) <= 1:
            return f"Ready for {campus}! What were your numbers today?"

        # Default friendly response
        if campus:
            return f"Perfect! Ready for {campus} stats."

        self.current_campus = None
        return "Hey! Which campus are you reporting for today?"
    
    # def get_stat_total(self, campus: str, stat_key: str, year: Optional[int] = None, month: Optional[int] = None) -> Optional[int]:
        """Return total stat value for a campus optionally filtered by year and month"""
        if not self.sheets_client or not self.spreadsheet:
            return None
        try:
            worksheet = self.spreadsheet.sheet1
            records = worksheet.get_all_records()
            total = 0
            for row in records:
                if row.get('Campus') != campus:
                    continue
                date_str = row.get('Sunday Date')
                if not date_str:
                    continue
                try:
                    row_date = datetime.strptime(date_str, '%Y-%m-%d')
                    if year and row_date.year != year:
                        continue
                    if month and row_date.month != month:
                        continue
                except ValueError:
                    continue
                
                # Map stat_key to actual column name
                column_mapping = {
                    'total_attendance': 'Total Attendance',
                    'new_people': 'New People',
                    'new_christians': 'New Christians',
                    'youth_attendance': 'Youth Attendance',
                    'new_youth': 'New Youth',
                    'new_youth_christians': 'New Youth Christians',
                    'kids_total': 'Kids Total',
                    'new_kids': 'New Kids',
                    'kids_salvations': 'Kids Salvations',
                    'connect_groups': 'Connect Groups'
                }
                
                column_name = column_mapping.get(stat_key, stat_key.replace('_', ' ').title())
                value = row.get(column_name)
                
                if isinstance(value, int):
                    total += value
                elif isinstance(value, str) and value.isdigit():
                    total += int(value)
            return total if total > 0 else None
        except Exception as e:
            logger.error(f"‚ùå Failed to fetch totals for {campus}, {stat_key}: {e}")
            return None
    
    # @lru_cache(maxsize=100)
    # def get_all_sheets_data_cached(self, cache_key: str) -> List[Dict]:
        """Cached method to get all sheets data - reduces API calls"""
        if not self.sheets_client or not self.spreadsheet:
            return []
        try:
            worksheet = self.spreadsheet.sheet1
            return worksheet.get_all_records()
        except Exception as e:
            logger.error(f"‚ùå Failed to get cached sheets data: {e}")
            return []

    # def get_stat_total_optimized(self, campus: str, stat_key: str, year: Optional[int] = None, month: Optional[int] = None) -> Optional[int]:
        """Optimized version using cached data"""
        try:
            cache_key = f"stats_{int(time.time() // 300)}"  # 5-minute cache
            records = self.get_all_sheets_data_cached(cache_key)
            
            total = 0
            column_mapping = {
                'total_attendance': 'Total Attendance',
                'new_people': 'New People',
                'new_christians': 'New Christians',
                'youth_attendance': 'Youth Attendance',
                'new_youth': 'New Youth',
                'new_youth_christians': 'New Youth Christians',
                'kids_total': 'Kids Total',
                'new_kids': 'New Kids',
                'kids_salvations': 'Kids Salvations',
                'connect_groups': 'Connect Groups'
            }
            
            column_name = column_mapping.get(stat_key, stat_key.replace('_', ' ').title())
            
            for row in records:
                if row.get('Campus') != campus:
                    continue
                    
                if year or month:
                    date_str = row.get('Sunday Date')
                    if date_str:
                        try:
                            row_date = datetime.strptime(date_str, '%Y-%m-%d')
                            if year and row_date.year != year:
                                continue
                            if month and row_date.month != month:
                                continue
                        except ValueError:
                            continue
                
                value = row.get(column_name)
                if isinstance(value, int):
                    total += value
                elif isinstance(value, str) and value.isdigit():
                    total += int(value)
            
            return total if total > 0 else None
        except Exception as e:
            logger.error(f"‚ùå Failed to get optimized total for {campus}: {e}")
            return self.get_stat_total(campus, stat_key, year, month)  # Fallback
    
    def get_average_stat(self, campus, stat_key):
        if not self.spreadsheet:
            return None
        records = self.spreadsheet.sheet1.get_all_records()
        values = [int(r.get(stat_key.replace('_', ' ').title(), 0)) for r in records if r['Campus'] == campus]
        return sum(values) / len(values) if values else None
    
    async def generate_elevenlabs_audio(self, text: str, test_mode: bool = False, retry_count: int = 0, max_retries: int = 3) -> Optional[bytes]:
        """Generate ElevenLabs audio - async with caching and retries"""
        if not self.use_elevenlabs or not text.strip():
            return None
        
        start_time = time.time()
        try:
            url = f"https://api.elevenlabs.io/v1/text-to-speech/{self.elevenlabs_voice_id}"
            
            headers = {
                "Accept": "audio/mpeg",
                "Content-Type": "application/json",
                "xi-api-key": self.elevenlabs_api_key
            }
            
            clean_text = re.sub(r'[^\w\s\.,!?]', '', text)
            clean_text = clean_text[:500] if test_mode else clean_text[:1000]
            
            data = {
                "text": clean_text,
                "model_id": "eleven_turbo_v2_5",
                "voice_settings": {
                    "stability": 0.75,
                    "similarity_boost": 0.8,
                    "style": 0.2,
                    "use_speaker_boost": True
                },
                "optimize_streaming_latency": 3,
                "output_format": "mp3_44100_128"
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post(url, json=data, headers=headers, timeout=30) as response:
                    if response.status == 200:
                        audio_content = await response.read()
                        if len(audio_content) < 100:
                            logger.warning("‚ö†Ô∏è ElevenLabs returned small audio file")
                            return None
                        
                        if not (audio_content.startswith(b'ID3') or audio_content[0:2] == b'\xff\xfb'):
                            logger.warning("‚ö†Ô∏è ElevenLabs returned invalid MP3")
                            return None
                            
                        logger.info(f"‚úÖ Generated {len(audio_content)} bytes of audio in {time.time() - start_time:.2f}s")
                        return audio_content
                    elif response.status == 429 and retry_count < max_retries:
                        wait_time = 2 ** retry_count
                        logger.warning(f"‚ö†Ô∏è ElevenLabs rate limit exceeded, retrying in {wait_time}s")
                        await asyncio.sleep(wait_time)
                        return await self.generate_elevenlabs_audio(text, test_mode, retry_count + 1, max_retries)
                    elif response.status == 401:
                        logger.error("‚ùå ElevenLabs API key invalid")
                        self.use_elevenlabs = False
                        return None
                    else:
                        logger.error(f"‚ùå ElevenLabs API error: {response.status}")
                        return None
                        
        except Exception as e:
            logger.error(f"‚ùå ElevenLabs generation failed: {e}")
            return None
    
    def log_to_sheets_background(self, stats: Dict):
        """Log to Google Sheets in background"""
        if not self.sheets_client or not stats:
            return False
        
        def _log_background():
            try:
                worksheet = self.spreadsheet.sheet1
                
                today = datetime.now()
                days_since_sunday = (today.weekday() + 1) % 7
                sunday_date = (today - timedelta(days=days_since_sunday)).strftime('%Y-%m-%d')
                timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                
                headers = [
                    'Timestamp', 'Sunday Date', 'Campus', 'Total Attendance',
                    'New People', 'New Christians', 'Youth Attendance',
                    'New Youth', 'New Youth Christians', 'Kids Total',
                    'New Kids', 'Connect Groups', 'Kids Salvations'
                ]
                row = [
                    timestamp,
                    sunday_date,
                    stats.get('campus', ''),
                    stats.get('total_attendance', ''),
                    stats.get('new_people', ''),
                    stats.get('new_christians', ''),
                    stats.get('youth_attendance', ''),
                    stats.get('new_youth', ''),
                    stats.get('new_youth_christians', ''),
                    stats.get('kids_total', ''),
                    stats.get('new_kids', ''),
                    stats.get('connect_groups', ''),
                    stats.get('kids_salvations', '')
                ]
                
                worksheet.append_row(row)
                logger.info(f"‚úÖ Logged {stats.get('campus', 'stats')} to Google Sheets")
                return True
                
            except Exception as e:
                logger.error(f"‚ùå Sheets logging failed: {e}")
                return False
        
        try:
            self.thread_pool.submit(_log_background)
            return True
        except Exception as e:
            logger.error(f"‚ùå Failed to submit background task: {e}")
            return False
    
    def update_conversation_memory(self, user_input: str, assistant_response: str, stats: Dict):
        """Update conversation memory"""
        conversation_entry = {
            'timestamp': datetime.now().isoformat(),
            'user': user_input,
            'assistant': assistant_response,
            'stats': stats,
            'campus': stats.get('campus') if stats else None
        }

        campus = stats.get('campus') or self.current_campus
        if campus:
            if campus not in self.conversation_history:
                self.conversation_history[campus] = []
            self.conversation_history[campus].append(conversation_entry)

        # Save stats to session memory
        if stats and 'campus' in stats:
            campus = stats['campus']
            if campus not in self.session_stats:
                self.session_stats[campus] = []
            # Only append if this stats dict is not a duplicate of the last one for this campus
            if not self.session_stats[campus] or self.session_stats[campus][-1] != stats:
                self.session_stats[campus].append(stats)

        # Store most recent stat snapshot for long-term comparisons
        if stats and 'campus' in stats:
            campus = stats['campus']
            self.previous_stats_by_campus[campus] = stats

        # --- NEW: Log stat record to JSON file and Google Sheets (if enabled) ---
        # Only if this is a stats submission (len(stats) > 2 and campus present)
        if stats and 'campus' in stats and len(stats) > 2:
            # Create a new stat record with timestamp
            stat_record = {
                "Timestamp": datetime.now().isoformat(),
                "Campus": campus,
                "total_attendance": stats.get("total_attendance", ""),
                "new_people": stats.get("new_people", ""),
                "new_christians": stats.get("new_christians", ""),
                "youth_attendance": stats.get("youth_attendance", ""),
                "kids_total": stats.get("kids_total", ""),
                "connect_groups": stats.get("connect_groups", "")
            }
            # Save to local JSON file
            json_path = os.path.join("data", "logged_stats.json")
            if os.path.exists(json_path):
                try:
                    with open(json_path, "r") as f:
                        existing = json.load(f)
                except Exception:
                    existing = []
            else:
                existing = []
            existing.insert(0, stat_record)  # latest at top
            try:
                with open(json_path, "w") as f:
                    json.dump(existing, f, indent=2)
            except Exception as e:
                logging.warning(f"Failed to write to JSON file: {e}")
            # Save to Google Sheets if enabled
            if GSPREAD_AVAILABLE:
                try:
                    sheet = getattr(self, "spreadsheet", None)
                    if sheet is not None:
                        worksheet = sheet.sheet1
                        worksheet.append_row([
                            stat_record["Timestamp"],
                            campus,
                            stat_record["total_attendance"],
                            stat_record["new_people"],
                            stat_record["new_christians"],
                            stat_record["youth_attendance"],
                            stat_record["kids_total"],
                            stat_record["connect_groups"]
                        ])
                except Exception as e:
                    logging.warning(f"Google Sheets append failed: {e}")

        # Save memory every 3 conversations or if the conversation is a stats submission (len(stats) > 2)
        if len(self.conversation_history) % 3 == 0 or (stats and 'campus' in stats and len(stats) > 2):
            self.save_memory()
    
    def cleanup_old_audio_files(self):
        """Clean up old audio files"""
        try:
            audio_dir = 'temp_audio'
            if os.path.exists(audio_dir):
                now = time.time()
                files_cleaned = 0
                for filename in os.listdir(audio_dir):
                    if filename.endswith('.mp3'):
                        filepath = os.path.join(audio_dir, filename)
                        if os.path.getctime(filepath) < now - 3600:
                            os.remove(filepath)
                            files_cleaned += 1
                if files_cleaned > 0:
                    logger.info(f"üßπ Cleaned up {files_cleaned} old audio files")
        except Exception as e:
            logger.error(f"‚ùå Audio cleanup error: {e}")

    def get_session_summary(self) -> str:
        """Generate session summary"""
        if not self.session_stats:
            return "No stats logged this session yet."
        
        summary_parts = []
        for campus, stats_list in self.session_stats.items():
            latest_stats = stats_list[-1]
            attendance = latest_stats.get('total_attendance', 'N/A')
            new_people = latest_stats.get('new_people', 'N/A')
            summary_parts.append(f"{campus}: {attendance} people, {new_people} new")
        
        return "Session summary: " + " | ".join(summary_parts)
    
    # def get_insights_data(self) -> Dict:
        """Generate insights data for the dashboard"""
        if not self.sheets_client or not self.spreadsheet:
            return {}
        
        try:
            worksheet = self.spreadsheet.sheet1
            records = worksheet.get_all_records()
            current_year = datetime.now().year
            
            # Calculate insights
            insights = {
                'top_growing_campus': None,
                'total_salvations_this_year': 0,
                'attendance_trend': 'stable',
                'youth_growth_percentage': 0
            }
            
            # Find top growing campus this month
            campus_growth = {}
            for campus in self.campuses:
                current_month_attendance = self.get_stat_total(campus, 'total_attendance', current_year, datetime.now().month)
                last_month_attendance = self.get_stat_total(campus, 'total_attendance', current_year, datetime.now().month - 1)
                
                if current_month_attendance and last_month_attendance and last_month_attendance > 0:
                    growth = ((current_month_attendance - last_month_attendance) / last_month_attendance) * 100
                    campus_growth[campus] = growth
            
            if campus_growth:
                insights['top_growing_campus'] = max(campus_growth.items(), key=lambda x: x[1])
            
            # Total salvations this year
            insights['total_salvations_this_year'] = sum(
                self.get_stat_total(campus, 'new_christians', current_year) or 0 
                for campus in self.campuses
            )
            
            return insights
            
        except Exception as e:
            logger.error(f"‚ùå Failed to generate insights: {e}")
            return {}
    
    def cleanup_on_exit(self):
        """Cleanup on exit"""
        try:
            self.save_memory()
            self.cleanup_old_audio_files()
            self.thread_pool.shutdown(wait=False)
            logger.info("‚úÖ Application cleanup completed")
        except Exception as e:
            logger.error(f"‚ùå Cleanup error: {e}")

    def check_for_nudges(self):
        return None

assistant = None

# CSP configuration
csp = {
    'default-src': "'self'",
    'script-src': ["'self'", "'unsafe-inline'"],  # Allow inline scripts
    'style-src': ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
    'font-src': ["'self'", "https://fonts.gstatic.com"],
    'connect-src': ["'self'", 'https://api.elevenlabs.io', 'https://api.anthropic.com'],
    'media-src': ["'self'", 'blob:'],
    'img-src': ["'self'", 'data:']
}
Talisman(app, force_https=False, strict_transport_security=False, content_security_policy=csp)

@app.route('/')
def index():
    """Serve the main dashboard"""
    nonce = base64.b64encode(os.urandom(16)).decode('utf-8')
    try:
        return render_template("index.html", nonce=nonce)
    except Exception as e:
        logger.error(f"‚ùå Failed to render template: {e}")
        return f"Template error: {e}", 500

@app.route('/favicon.ico')
def favicon():
    """Serve favicon"""
    try:
        favicon_path = os.path.join(app.static_folder, 'favicon.ico')
        if os.path.exists(favicon_path):
            return send_from_directory(app.static_folder, 'favicon.ico')
        else:
            return '', 204
    except Exception as e:
        logger.error(f"Error serving favicon.ico: {str(e)}")
        return '', 204

@app.route('/api/stats', methods=['GET'])
def get_all_stats():
    """Return all available stats from Google Sheets, optionally filtered by campus, sorted latest first, with dynamic encouragements"""
    global assistant
    if not assistant or not assistant.sheets_client or not assistant.spreadsheet:
        return jsonify({'error': 'Assistant or Sheets not initialized'}), 500

    from datetime import datetime

    def parse_timestamp(ts):
        try:
            return datetime.fromisoformat(ts)
        except Exception:
            return datetime.min

    try:
        worksheet = assistant.spreadsheet.sheet1
        # Parse Google Sheet rows into records (list of dicts)
        records = worksheet.get_all_records()

        # Sort records by 'Timestamp' using parse_timestamp, latest first
        records.sort(key=lambda r: parse_timestamp(str(r.get("Timestamp", ""))), reverse=True)

        stats_list = []
        for row in records:
            try:
                # Provide both youth_attendance and fallback to youth_total if missing
                youth_attendance = row.get('Youth Attendance')
                youth_total = row.get('Youth Total')
                # Try to cast to int, fallback to 0 if not possible
                def safe_int(val):
                    try:
                        return int(val)
                    except Exception:
                        return 0
                stat = {
                    'date': row.get('Sunday Date'),
                    'campus': row.get('Campus'),
                    'total_attendance': safe_int(row.get('Total Attendance')),
                    'new_people': safe_int(row.get('New People')),
                    'new_christians': safe_int(row.get('New Christians')),
                    # Consistent youth attendance key
                    'youth_attendance': safe_int(youth_attendance) if youth_attendance not in (None, '') else safe_int(youth_total),
                    'kids_total': safe_int(row.get('Kids Total')),
                    'connect_groups': safe_int(row.get('Connect Groups'))
                }
                stats_list.append(stat)
            except Exception as row_error:
                logger.warning(f"‚ö†Ô∏è Skipped row due to error: {row_error}")

        campus = request.args.get("campus")
        if campus:
            stats_list = [r for r in stats_list if str(r.get("campus", "")).lower() == campus.lower()]
        # Sort stats_list by 'date' using parse_timestamp, latest first
        stats_list.sort(key=lambda r: parse_timestamp(r.get("date", "")), reverse=True)

        # --- Dynamic Encouragements ---
        encouragements = []
        # Example logic: Most recent stat, trends, etc.
        if stats_list:
            # Most recent record
            recent = stats_list[0]
            # Encourage if new Christians
            if recent.get('new_christians', 0) > 0:
                encouragements.append(f"üéâ {recent['campus']} saw {recent['new_christians']} new Christians!")
            # Attendance milestone
            if recent.get('total_attendance', 0) >= 300:
                encouragements.append(f"üëè {recent['campus']} had over 300 in attendance recently!")
            # New people
            if recent.get('new_people', 0) >= 10:
                encouragements.append(f"üåü {recent['campus']} welcomed {recent['new_people']} new people!")
            # Growth trend (compare last two records for this campus)
            campus_records = [r for r in stats_list if r['campus'] == recent['campus']]
            if len(campus_records) >= 2:
                prev = campus_records[1]
                if prev.get('total_attendance', 0) > 0:
                    diff = recent['total_attendance'] - prev['total_attendance']
                    if abs(diff) >= 10:
                        direction = "up" if diff > 0 else "down"
                        encouragements.append(f"üìà Attendance is {direction} by {abs(diff)} compared to last week at {recent['campus']}.")
        # Optionally, add more dynamic logic here for other stat-based encouragements.

        return jsonify({
            "stats": stats_list,
            "encouragements": encouragements
        })
    except Exception as e:
        logger.error(f"‚ùå Failed to load all stats: {e}")
        return jsonify({'error': 'Failed to retrieve stats from sheets'}), 500

@app.route('/api/process_voice', methods=['POST'])
def process_voice():
    """üî• ENHANCED: Voice processing endpoint with Claude AI (error-safe version)"""
    # (Removed invalid code: global and return statements outside function)
    try:
        data = request.get_json(force=True)
        if not isinstance(data, dict):
            logger.error(f"‚ùå Invalid input type. Got {type(data).__name__} instead of dict.")
            return jsonify({'error': 'Invalid request format. Expected a JSON object.'}), 400
        text = data.get('text', '').strip()
        if not text:
            return jsonify({'error': 'Text input is empty or missing.'}), 400
    except Exception as parse_error:
        logger.error(f"‚ùå Failed to parse JSON: {parse_error}")
        return jsonify({'error': 'Malformed JSON in request.'}), 400

    logger.info(f"üéôÔ∏è Voice input received: {text}")

    # Session reset check
    if 'new session' in text.lower():
        assistant.current_campus = None
        # Data recall (insights) temporarily disabled
        return jsonify({
            'text': 'Futures Link with Claude is live. How can I help you today?',
            'campus': None,
            'audio_url': None,
            'stats': {},
            'session_summary': None,
            # 'insights': assistant.get_insights_data()
        })

    # Parse stats once
    stats = assistant.parse_stats_enhanced(text)
    campus = stats.get('campus', assistant.current_campus)

    if campus:
        stats['campus'] = campus
        if campus != assistant.current_campus:
            logger.info(f"üîÅ Switching campus from {assistant.current_campus} to {campus}")
        assistant.current_campus = campus

    # Manual campus switch
    if "switch to" in text.lower() or "reporting for" in text.lower():
        potential_campus = assistant.extract_campus_enhanced(text)
        if potential_campus:
            logger.info(f"üîÄ Manual campus switch to: {potential_campus}")
            assistant.current_campus = potential_campus
            return jsonify({
                'text': f"Switched to {potential_campus}. Ready for your stats.",
                'campus': potential_campus,
                'audio_url': None,
                'stats': {},
                'campus_switched': True,
                'insights': assistant.get_insights_data()
            })

    # üî• ENHANCED: Check if they're asking for data vs providing data
    context = f"Voice request for {campus}" if campus else "Voice request"
    # stat_query_response = None
    # Only do data lookup if they're asking questions
    # if assistant.is_asking_for_data(text):
    #     stat_query_response = assistant.handle_stat_query(text)

    # Replace the following block with error-safe version as requested:
    try:
        assistant_response = None
        # if stat_query_response:
        #     assistant_response = stat_query_response
        # else:
        assistant_response = assistant.generate_claude_response(text, stats, context)
        logger.info(f"‚úÖ Assistant response: {assistant_response}")
        # Update memory
        assistant.update_conversation_memory(text, assistant_response, stats)
        # Log to sheets if needed
        if stats and 'campus' in stats and len(stats) > 2:
            assistant.log_to_sheets_background(stats)
        # Check nudges
        nudge = None  # disable nudges completely
        # if nudge:
        #     assistant_response += f"\n{nudge}"
        # Generate audio response
        audio_url = None
        if assistant.use_elevenlabs and assistant_response:
            audio_content = asyncio.run(assistant.generate_elevenlabs_audio(assistant_response))
            if audio_content:
                filename = f"speech_{uuid.uuid4().hex[:8]}.mp3"
                path = os.path.join('temp_audio', filename)
                with open(path, 'wb') as f:
                    f.write(audio_content)
                audio_url = f"/api/audio/{filename}"
        response = {
            'audio_url': audio_url,
            'text': assistant_response,
            'stats': assistant.session_stats,
            # 'session_summary': assistant.get_session_summary(),
            # 'insights': assistant.get_insights_data(),
            'campus': assistant.current_campus,
            'system_status': getattr(assistant, 'system_status', None)
        }
        return jsonify(response)
    except Exception as e:
        logger.exception("‚ùå Error during voice input processing")
        return jsonify({'error': f'Internal error: {str(e)}'}), 500

@app.route('/api/stats/<campus>')
def get_campus_stats(campus):
    """Get current stats for a specific campus - BULLETPROOF VERSION"""
    global assistant
    if not assistant:
        return jsonify({'error': 'Assistant not initialized'}), 500

    # Data recall endpoint temporarily disabled for logging focus
    return jsonify({'error': 'Data recall endpoint is currently disabled.'}), 501

@app.route('/api/insights')
# def get_insights():
#     """Get dashboard insights"""
#     global assistant
#     if not assistant:
#         return jsonify({'error': 'Assistant not initialized'}), 500
#     
#     try:
#         insights = assistant.get_insights_data()
#         return jsonify(insights)
#     except Exception as e:
#         logger.error(f"‚ùå Failed to get insights: {e}")
#         return jsonify({'error': 'Failed to retrieve insights'}), 500

@app.route('/api/audio/<filename>')
def serve_audio(filename):
    """Serve ElevenLabs audio files with range request support"""
    try:
        if not filename.endswith('.mp3') or '..' in filename or '/' in filename:
            return "Invalid filename", 400
        audio_path = os.path.join('temp_audio', filename)
        if os.path.exists(audio_path):
            return send_file(
                audio_path,
                mimetype='audio/mpeg',
                as_attachment=False,
                conditional=True
            )
        else:
            logger.warning(f"Audio file not found: {filename}")
            return "Audio file not found", 404
    except Exception as e:
        logger.error(f"‚ùå Error serving audio: {e}")
        return "Error serving audio", 500

@app.route('/api/session', methods=['GET'])
def get_session_summary():
    """Get current session summary with enhanced data (data recall disabled)"""
    global assistant
    if assistant:
        # insights = assistant.get_insights_data()
        return jsonify({
            'summary': assistant.get_session_summary(),
            'conversation_count': len(assistant.conversation_history),
            'current_campus': assistant.current_campus,
            'available_campuses': assistant.campuses,
            # 'insights': insights
        })
    return jsonify({
        'summary': 'No active session', 
        'conversation_count': 0,
        'error': 'assistant_not_initialized'
    })

@app.route('/api/health', methods=['GET'])
def health_check():
    """Enhanced health check endpoint"""
    global assistant
    
    health_status = {
        'status': 'healthy' if assistant else 'unhealthy',
        'timestamp': datetime.now().isoformat(),
        'services': {},
        'version': '3.0-claude-enhanced-fixed'
    }
    
    if assistant:
        health_status['services'] = {
            'claude': assistant.claude_client is not None,
            'elevenlabs': assistant.use_elevenlabs,
            'google_sheets': assistant.sheets_client is not None,
            'memory_system': os.path.exists(assistant.memory_file)
        }
        
        # Add system metrics
        health_status['metrics'] = {
            'campuses_configured': len(assistant.campuses),
            'conversations_this_session': len(assistant.conversation_history),
            'active_campus': assistant.current_campus
        }
    
    status_code = 200 if assistant else 503
    return jsonify(health_status), status_code

@app.route('/api/summary/weekend', methods=['GET'])
# def weekend_summary():
#     """Get weekend summary across all campuses"""
#     global assistant
#     if not assistant or not assistant.sheets_client or not assistant.spreadsheet:
#         return jsonify({'error': 'Assistant or Sheets not initialized'}), 500
#     try:
#         worksheet = assistant.spreadsheet.sheet1
#         records = worksheet.get_all_records()
#         today = datetime.now()
#         days_since_sunday = (today.weekday() + 1) % 7
#         last_sunday = (today - timedelta(days=days_since_sunday)).strftime('%Y-%m-%d')
#         summary = []
#         total_attendance = 0
#         total_salvations = 0
#         total_new_people = 0
#         for campus in assistant.campuses:
#             campus_data = [r for r in records if r.get('Campus') == campus and r.get('Sunday Date') == last_sunday]
#             if not campus_data:
#                 continue
#             row = campus_data[-1]
#             attendance = int(row.get('Total Attendance', 0))
#             new_people = int(row.get('New People', 0))
#             salvations = int(row.get('New Christians', 0))
#             total_attendance += attendance
#             total_new_people += new_people
#             total_salvations += salvations
#             summary.append({
#                 'campus': campus,
#                 'attendance': attendance,
#                 'new_people': new_people,
#                 'salvations': salvations
#             })
#         if not summary:
#             return jsonify({'summary': 'No data found for the last Sunday.'})
#         return jsonify({
#             'summary': summary,
#             'totals': {
#                 'attendance': total_attendance,
#                 'new_people': total_new_people,
#                 'salvations': total_salvations
#             },
#             'date': last_sunday
#         })
#     except Exception as e:
#         logger.error(f"‚ùå Weekend summary failed: {e}")
#         return jsonify({'error': 'Failed to generate summary'}), 500

# REMOVED: All startup chime routes and pygame functions

@app.route('/api/nudges', methods=['GET'])
def get_nudges():
    global assistant
    if not assistant:
        return jsonify({'error': 'Assistant not initialized'}), 500
    
    nudge = assistant.check_for_nudges()
    return jsonify({'nudges': nudge or 'All good!'})

@app.errorhandler(404)
def not_found(error):
    return jsonify({'error': 'Endpoint not found'}), 404

@app.errorhandler(500)
def internal_error(error):
    logger.error(f"Internal server error: {error}")
    return jsonify({'error': 'Internal server error'}), 500

def main():
    """üöÄ Main application entry point - FIXED VERSION"""
    global assistant

    print("Starting Futures Link Assistant...")
    # print("=" * 50)

    # Initialize assistant with error handling
    try:
        global assistant
        assistant = EnhancedChurchAssistant()
        print("Assistant initialized successfully.")
    except Exception as e:
        # logger.error(f"‚ùå Assistant initialization failed: {e}")
        print("Assistant failed to initialize:", e)
        # Create minimal assistant for fallback
        assistant = type('obj', (object,), {
            'demo_stats': {
                'Paradise': {'attendance': 320, 'new': 12, 'salvations': 4},
                'Adelaide City': {'attendance': 450, 'new': 18, 'salvations': 6},
                'Salisbury': {'attendance': 280, 'new': 9, 'salvations': 3},
            },
            'current_campus': None,
            'conversation_history': [],
            'campuses': ['Paradise', 'Adelaide City', 'Salisbury', 'South'],
            'has_sheets': False,
            'has_voice': False,
            'has_claude': False
        })()

    port = int(os.getenv('PORT', 5001))
    host = '0.0.0.0'
    print(f"App running on: http://localhost:{port}")
    app.run(
        host=host,
        port=port,
        debug=False,
        threaded=True,
        use_reloader=False
    )

if __name__ == '__main__':
    main()